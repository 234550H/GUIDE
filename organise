import time, os
import re
import string
import random
import uuid
import pandas as pd
from io import BytesIO
from random import choice
import io
from flask import Flask, render_template, request, redirect, url_for, flash, session, get_flashed_messages, send_file,\
    jsonify
from datetime import date,datetime
import shelve

#for statistics
import matplotlib.pyplot as plt
from collections import Counter

from models import save_product, get_products, update_product, delete_product, delete_category, save_category
from models import get_categories, get_product_by_id,get_database_pd,get_category_by_id,update_dbcategory,\
    get_top_5_products,store_won_gifts,retrieve_won_gifts,perform_search

from models import store_chat_messages,retrieve_chat_messages,retrieve_amount_spent, store_amount_spent, \
    store_subscribed_email, retrieve_subscribed_emails,get_cart_items,save_cart_items,add_to_cart,\
    clear_cart,remove_from_cart,calculate_total_price

from models import get_metallix_products,get_biopack_products,get_restyle_products,get_greentech_products
import Customer, Staff
from Forms import *




app = Flask(__name__)
app.config['SECRET_KEY'] = 'my messages'  # Change this to a secret key


def validate_username(username):
    pattern = r'^[a-zA-Z0-9_-]{3,20}$'
    return re.match(pattern, username) is not None


def validate_password(password):
    return len(password) >= 8


def get_username(username):
    with shelve.open('users.db', flag='r', protocol=3) as shelve_db:
        if username in shelve_db:
            return username
    return None


@app.route('/')
def index():
    # Default greeting message
    default_message = "Hello! I'm a chatbot. How can I assist you today?"
    # Determine state of user (check if user is logged in)
    if session.get('email') == None or session.get('email') == 'checkout':
        session['email'] = 'guest'
    return render_template('index.html',current_url=request.path)


#Moira codes part
# sign-ups and logins
@app.route('/account-navigation')
def account_navigation():
    return render_template('includes/accountnavigation/AccountNavigation.html', current_url=request.path)

# logout (to put in profile icon dropdown)
@app.route('/logout')
def logout():
    session.pop('email', None)
    return redirect(url_for('index'))

# customer sign up
@app.route('/CustomerSignUp', methods=['GET', 'POST'])
def customer_signup():
    db = shelve.open('Shelves/Customer.db', 'c', writeback=True)
    customer_data = db.get('customer_key', {})
    customer_signup = CustomerSignUp(request.form)
    error = None
    error_username = None
    error_birthdate = None
    error_mobile_number = None
    error_email = None
    error_password = None
    error_confirm_password = None
    try:
        if request.method == 'POST':
            #validations
            today = date.today()
            if customer_signup.email.data in customer_data:
                error_email = "This account is already registered. Please Sign in."
            elif not customer_signup.username.data.isalnum():
                error_username = "Username must only contain letters and numbers."
            elif customer_signup.birthdate.data >= today or customer_signup.birthdate.data < date(1900, 1, 1):
                error_birthdate = 'Birthdate must be in the past.'
            elif customer_signup.mobile_number.data.isdigit() == False:
                error_mobile_number = 'Please enter a valid mobile number.'
            elif len(customer_signup.mobile_number.data) != 8:
                error_mobile_number = 'Mobile number must be from Singapore.'
            elif not customer_signup.password.data.isalnum() or customer_signup.password.data.isalpha() \
                    or customer_signup.password.data.isdigit():
                error_password = "Password must contain both letters and numbers only."
            elif not 8 <= len(customer_signup.password.data) <= 32:
                error_password = "Password must be between 8 to 32 characters long."
            elif customer_signup.password.data != customer_signup.confirm_password.data:
                error_confirm_password = "Passwords must match."
            else:
                error = None
                # Access the birthdate field using the 'data' attribute
                birthdate = customer_signup.birthdate.data
                if birthdate is not None:
                    # Create a Customer object using the form data
                    customer = Customer.Customer(customer_signup.username.data,
                                                 birthdate.strftime('%Y-%m-%d'),
                                                 customer_signup.mobile_number.data,
                                                 customer_signup.email.data,
                                                 customer_signup.password.data)
                    customer_data[customer_signup.email.data] = customer # Use email as a key in the dictionary
                    db['customer_key'] = customer_data
                    print(session)
                    # check if user needs to go to transaction page
                    if session['email'] == 'checkout':
                        session['email'] = customer_signup.email.data
                        db.close()
                        return redirect(url_for('payment_transaction'))
                    else:
                        session['email'] = customer_signup.email.data
                        db.close()
                        return render_template('index.html', current_url=request.path)
    except Exception as e:
        error = f"An error occurred: {e}"
    return render_template('includes/accountnavigation/CustomerSignUp.html', form=customer_signup, current_url=request.path,
                           error=error, error_username=error_username, error_birthdate=error_birthdate,
                           error_mobile_number = error_mobile_number, error_email=error_email,
                           error_password=error_password, error_confirm_password=error_confirm_password)

# customer login
@app.route('/CustomerLogin', methods=['GET', 'POST'])
def customer_login():
    customer_login_form = CustomerLogin(request.form)
    error = None
    try:
        if request.method == 'POST' and customer_login_form.validate():
            db = shelve.open('Shelves/Customer.db', 'r')
            email = customer_login_form.email.data
            password = customer_login_form.password.data
            customer_data = db.get('customer_key', {})

            if email in customer_data and customer_data[email].get_password() == password:
                # check if user needs to go to transaction page
                if session['email'] == 'checkout':
                    # Store the username in the session
                    session['email'] = customer_login_form.email.data
                    db.close()
                    return redirect(url_for('payment_transaction'))
                else:
                    session['email'] = customer_login_form.email.data
                    db.close()
                    return render_template('index.html', current_url=request.path)
            else:
                error = 'Username or password is incorrect.'
    except Exception as e:
        error = f"An error occurred: {str(e)}"

    return render_template('includes/accountnavigation/CustomerLogin.html', form=customer_login_form, current_url=request.path,
                           error=error)

# customer forgot password
@app.route('/customerforgotpassword', methods=['GET', 'POST'])
def customer_forgot_password():
    reset_password_form = CustomerForgotPassword(request.form)
    error = None
    email = reset_password_form.email.data
    new_password = reset_password_form.password.data
    try:
        if request.method == 'POST' and reset_password_form.validate():
            db = shelve.open('Shelves/Customer.db', 'c')
            customer_data = db.get('customer_key', {})
            if email in customer_data:
                # validations
                if not 8 <= len(new_password) <= 32:
                    error = "Password must be between 8 to 32 characters long."
                elif not new_password.isalnum() or new_password.isalpha() or new_password.isdigit():
                    error = "Password must contain both letters and numbers only."
                else:
                    error = None
                    customer_data[email].set_password(new_password)
                    # Update data in dictionary
                    customer_data[email] = Customer.Customer(customer_data[email].get_username(),
                                                             customer_data[email].get_birthdate(),
                                                             customer_data[email].get_mobile_number(),
                                                             customer_data[email].get_email(),
                                                             new_password)
                    db['customer_key'] = customer_data  # Update data in shelve
                    db.sync()
                    db.close()
                    return redirect(url_for('customer_login'))
            else:
                error = "Email does not exist."
    except Exception as e:
        error = f"An error occurred: {str(e)}"
        print(error)
    return render_template('includes/accountnavigation/CustomerForgotPassword.html', form=reset_password_form,
                           current_url=request.path, error=error)

# database customer
@app.route('/db_customer')
def db_customer():
    # Retrieve customer data from the database or any other source
    with shelve.open('Shelves/Customer.db') as db:
        customer_data = db.get('customer_key', {})

    # Render the template with the customer_data variable
    return render_template('backend/db_customer.html', customer_data=customer_data)


# Customer account deletion
@app.route('/db_customer/delete_customer/<string:email>', methods=['POST'])
def delete_customer(email):
    db = shelve.open('Shelves/Customer.db', 'c', writeback=True)
    customer_data = db.get('customer_key', {})

    if email in customer_data:
        del customer_data[email]
        db['customer_key'] = customer_data
        db.close()
        return redirect(url_for('db_customer'))
    else:
        db.close()
        flash('Customer not found', 'danger')
        return render_template('backend/db_customer.html', customer_data=customer_data)


# staff login
@app.route('/StaffLogin', methods=['GET', 'POST'])
def staff_login():
    staff_login_form = StaffLogin(request.form)
    error = None
    email = staff_login_form.email.data
    password = staff_login_form.password.data
    try:
        if request.method == 'POST' and staff_login_form.validate():
            db = shelve.open('Shelves/Staff.db', 'r')
            staff_data = db.get('staff_key', {})
            if email in staff_data and staff_data[email].get_password() == password:
                # Store the username in the session
                session['email'] = staff_login_form.email.data
                db.close()
                return redirect(url_for('dashboard'))
            else:
                error = 'Username or password is incorrect.'
    except Exception as e:
        error = f"An error occurred: {str(e)}"

    return render_template('includes/accountnavigation/StaffLogin.html', form=staff_login_form, current_url=request.path,
                           error=error)

# staff forgot password
@app.route('/staffforgotpassword', methods=['GET', 'POST'])
def staff_forgot_password():
    reset_password_form = StaffForgotPassword(request.form)
    error = None
    email = reset_password_form.email.data
    new_password = reset_password_form.password.data
    try:
        if request.method == 'POST' and reset_password_form.validate():
            db = shelve.open('Shelves/Staff.db', 'c')
            staff_data = db.get('staff_key', {})
            print(email)
            print(staff_data)
            if email in staff_data:
                # validations
                if not 8 <= len(new_password) <= 32:
                    error = "Password must be between 8 to 32 characters long."
                elif not new_password.isalnum() or new_password.isalpha() or new_password.isdigit():
                    error = "Password must contain both letters and numbers only."
                else:
                    error = None
                    staff_data[email].set_password(new_password)
                    # Update data in dictionary
                    staff_data[email] = Staff.Stafflogin(staff_data[email].get_email(),
                                                         new_password)
                    db['staff_key'] = staff_data  # Update data in shelve
                    db.sync()
                    db.close()
                    return redirect(url_for('staff_login'))
            else:
                error = "Email does not exist."
    except Exception as e:
        error = f"An error occurred: {str(e)}"
        print(error)
    return render_template('includes/accountnavigation/StaffForgotPassword.html', form=reset_password_form,
                           current_url=request.path, error=error)


@app.route('/signup', methods=['POST'])
def signup():
    username = request.form['username']
    password = request.form['password']
    signup_error = None

    if not validate_username(username):
        signup_error = 'Invalid username. Use only letters, numbers, underscores, and hyphens. Length between 3 and 20 characters.'
    elif not validate_password(password):
        signup_error = 'Password must have at least 8 characters.'
    else:
        with shelve.open('users.db', writeback=True, flag='c', protocol=3) as shelve_db:
            if username in shelve_db:
                signup_error = 'Username already registered.'
            else:
                shelve_db[username] = {'password': password}
                return redirect(url_for('success'))

    return render_template('index.html', signup_error=signup_error, login_error=None)


# Backend display of all customer accounts,DONE BY Qifang
@app.route('/view_customers')
def view_customers():
    try:
        # Open the Shelve database in read mode
        db = shelve.open('Shelves/Customer.db', 'r')

        # Retrieve all customer data from the database
        customer_data = db.get('customer_key', {})

        # Close the Shelve database
        db.close()

        # Render the template with the customer data
        return render_template('backend/view_customer_acc.html', customer_data=customer_data)
    except Exception as e:
        error = f"An error occurred: {str(e)}"
        return render_template('error.html', error=error)

# payment transaction
@app.route('/paymenttransaction', methods=['GET', 'POST'])
def payment_transaction():
    email_key = session['email']
    if email_key == 'guest':
        session['email'] = 'checkout'
        print(session)
        return redirect(url_for('customer_login'))
    payment_transaction_form = PaymentTransaction(request.form)
    error = None
    error_name = None
    error_mobile_number = None
    error_email = None
    error_address = None
    error_zipcode = None
    error_card_number = None
    error_expiry_month = None

    if request.method == 'POST' and payment_transaction_form.validate():
        db = shelve.open('Shelves/Payments.db', 'c')
        order_data = db.get('OrderID', {})
        current_date = date.today()
        # Check if email matches with logged in email
        if email_key == payment_transaction_form.email.data:
            if payment_transaction_form.name.data.isdigit():
                error_name = "Name must only contain letters and spaces."
            elif payment_transaction_form.mobile_number.data.isdigit() == False:
                error_mobile_number = "Please enter a valid mobile number."
            elif len(payment_transaction_form.mobile_number.data) != 8:
                error_mobile_number = "Mobile number must be from Singapore."
            elif len(payment_transaction_form.zipcode.data) != 6 or payment_transaction_form.zipcode.data.isdigit() == False:
                error_zipcode = "Please enter a valid zipcode."
            elif len(payment_transaction_form.card_number.data) != 16 or payment_transaction_form.card_number.data.isdigit() == False:
                error_card_number = "Please enter a valid card number."
            elif payment_transaction_form.card_number.data[0] not in ('4', '5', '3'):
                error_card_number = "Only Visa, Mastercard and American Express cards are accepted."
            elif payment_transaction_form.expiry_month.data < current_date.replace(day=1):
                error_expiry_month = "Please enter a valid expiry month."
            else:
                # Access the birthdate field using the 'data' attribute
                expmonth = payment_transaction_form.expiry_month.data
                if expmonth is not None:
                    payment_method = None
                    card_number = payment_transaction_form.card_number.data
                    if card_number[0] == '4':
                        payment_method = 'Visa'
                    elif card_number[0] == '5':
                        payment_method = 'Mastercard'
                    elif card_number[0] == '3':
                        payment_method = 'American Express'
                    order = Customer.CustomerPaymentDetails(payment_transaction_form.name.data,
                                                            payment_transaction_form.mobile_number.data,
                                                            payment_transaction_form.email.data,
                                                            payment_transaction_form.address.data,
                                                            payment_transaction_form.zipcode.data,
                                                            payment_transaction_form.card_number.data,
                                                            expmonth.strftime('%m-%Y'),
                                                            payment_method)
                    order_id = str(uuid.uuid4())[:7] # Generate a random order id
                    order_data[order_id] = order
                    db['OrderID'] = order_data
                    db.close()
                    # Create a Customer object using the form data
                    session['form_data'] = payment_transaction_form.data
                    return redirect(url_for('payment_transaction_success', order_id=order_id))
                else:
                    error_expiry_month = "Please enter a valid expiry month."
        else:
            error_email = "Please use the same email you're logged in as."
    print(error)
    return render_template('includes/Transaction/paymenttransaction.html', form=payment_transaction_form,
                           current_url=request.path, error=error, error_name=error_name,
                           error_mobile_number=error_mobile_number, error_email=error_email,
                           error_address=error_address, error_zipcode=error_zipcode, error_card_number=error_card_number,
                           error_expiry_month=error_expiry_month)

# payment transaction success
@app.route('/payment_transaction_success/<order_id>', methods=['GET', 'POST'])
def payment_transaction_success(order_id):
    db = shelve.open('Shelves/Payments.db', 'c')
    cart_db = shelve.open('cart.db')

    order_data = db.get('OrderID', {})
    payment_method = order_data[order_id].get_payment_method()  # assuming payment_method is a property of the order object

    # Retrieve the cart items from the cart database
    cart_items = [{'product': get_product_by_id(key), 'quantity': value} for key, value in cart_db.items()]

    # Calculate the total price of the cart items
    amount = calculate_total_price(cart_items)

    # Calculate the total price
    total_price = calculate_total_price(cart_items)

    # Apply discounts based on total price
    if total_price >= 300:
        total_price -= 20
    elif total_price >= 200:
        total_price -= 15
    elif total_price >= 100:
        total_price -= 10

    # Save the order to purchase history
    save_order_to_purchase_history(order_id, order_data[order_id], payment_method, amount)

    # Close the databases
    db.close()
    cart_db.close()

    # Pass the total price (amount) to the template
    return render_template('includes/Transaction/Transaction_successful.html',
                           order_id=order_id, amount=total_price, payment_method=payment_method, current_url=request.path)


def save_order_to_purchase_history(order_id, order, payment_method, amount):
    # Open the purchase history database with 'c' flag to create if it doesn't exist
    purchase_history_db = shelve.open('purchase_history.db', 'c')

    # Add the order details to the purchase history database
    purchase_history_db[order_id] = {
        'order': order,
        'payment_method': payment_method,
        'amount': amount,
    }

    # Close the purchase history database
    purchase_history_db.close()
#End of Moira codes part above ^

# Dashboard route
@app.route('/dashboard')
def dashboard():
    # Retrieve the email from the session
    email = session.get('email')

    # If email is not in the session, redirect to the login page
    if not email:
        flash('Please log in to access the dashboard.', 'warning')
        return redirect(url_for('staff_login'))

    # Extract the part of the email before the '@' symbol
    email_name = email.split('@')[0]

    # Your dashboard logic here using the 'email' and 'email_name' variables

    return render_template('backend/dashboard.html', email=email, email_name=email_name)


@app.route('/success')
def success():
    return render_template('success.html')

# Sustainability
@app.route('/sustainability')
def sustainability():
    return render_template('includes/sustainability.html', current_url=request.path)


@app.route('/wheel')
def wheel():
    return render_template('includes/wheel.html')

free_gifts = [
    "Reglow sticker set",
    "Metal straw sets",
    "bamboo cutlery sets",
    "Reglow water bottle",
    "Reglow tote bag",
    "Reglow plushie"
]

@app.route('/spin', methods=['POST'])
def spin_wheel():
    # Choose a random free gift
    selected_gift = choice(free_gifts)

    # Store the won gift
    won_gifts = retrieve_won_gifts()
    won_gifts.append(selected_gift)
    store_won_gifts(won_gifts)

    return jsonify({'gift': selected_gift})

@app.route('/get_won_gifts')
def get_won_gifts():
    won_gifts = retrieve_won_gifts()
    return jsonify({'won_gifts': won_gifts})

@app.route('/delete_gift', methods=['POST'])
def delete_gift():
    gift_to_delete = request.form.get('gift')
    won_gifts = retrieve_won_gifts()

    if gift_to_delete in won_gifts:
        won_gifts.remove(gift_to_delete)
        store_won_gifts(won_gifts)
        return jsonify({'success': True})
    else:
        return jsonify({'success': False, 'message': 'Gift not found'}), 404

#coupons

@app.route('/mycoupons')
def my_coupons():
    won_gifts = retrieve_won_gifts()
    return render_template('includes/coupons.html', won_gifts=won_gifts)

# List to store generated promo codes
generated_promo_codes = []

#End of Hui Xin code

#FAQ pages
@app.route('/FAQ')
def FAQ():
    return render_template('includes/FAQ.html', current_url=request.path)

#PAYMENT METHODS
@app.route('/payment_methods')
def payment_methods():
    return render_template('includes/payment_methods.html', current_url=request.path)

# Quiz
@app.route('/quiz', methods=['GET', 'POST'])
def quiz():
    if request.method == 'POST':
        # Handle form submission and store data in the database
        num_wastes = request.form['Nowaste']
        waste_type = request.form['wasteType']

        # Retrieve or initialize the quiz counter
        with shelve.open('counters') as counters_db:
            quiz_counter = counters_db.get('quiz_counter', 0)
            quiz_id = str(quiz_counter + 1)
            counters_db['quiz_counter'] = quiz_counter + 1

        # Save data in the shelve database
        with shelve.open('quiz_data') as db:
            db[quiz_id] = {
                'num_wastes': num_wastes,
                'waste_type': waste_type
            }

        # Redirect to the thank-you page with the quiz_id
        return redirect(url_for('thank_you_quiz', quiz_id=quiz_id))
    return render_template('includes/quiz.html', current_url=request.path)


@app.route('/thank_you_quiz/<quiz_id>')
def thank_you_quiz(quiz_id):
    return render_template('includes/thank_you_quiz.html', quiz_id=quiz_id)

# Route to view submitted quiz data
@app.route('/view_quiz_results')
def view_quiz_results():
    # Retrieve all quiz data from the shelve database
    with shelve.open('quiz_data') as db:
        quiz_data = list(db.values())

    return render_template('includes/view_quiz_results.html', quiz_data=quiz_data)

#membership
cumulative_amounts = retrieve_amount_spent() or []

@app.route('/edit_amount_spent', methods=['POST'])
def edit_amount_spent():
    try:
        amount_spent = int(request.form.get('amount_spent'))

        # Append the new amount to the cumulative_amounts list
        cumulative_amounts.append(amount_spent)

        # Store the updated cumulative amounts in shelve
        store_amount_spent(cumulative_amounts)

        return jsonify(success=True)

    except ValueError as ve:
        return jsonify(error=f"Invalid amount provided: {str(ve)}")

    except Exception as e:
        return jsonify(error=f"An error occurred: {str(e)}")

def calculate_total_amount_spent():
    return sum(cumulative_amounts)

@app.route('/get_amount_spent')
def get_amount_spent():
    total_amount_spent = calculate_total_amount_spent()
    return jsonify({'amount_spent': total_amount_spent})

@app.route('/update_amount_spent', methods=['POST'])
def update_amount_spent():
    try:
        amount_spent = int(request.form.get('amount_spent'))

        # Store the cumulative amount directly
        cumulative_amounts.clear()
        cumulative_amounts.append(amount_spent)

        return jsonify(success=True)

    except ValueError as ve:
        return jsonify(error=f"Invalid amount provided: {str(ve)}")

    except Exception as e:
        return jsonify(error=f"An error occurred: {str(e)}")

@app.route('/reset_amount_spent', methods=['POST'])
def reset_amount_spent():
    cumulative_amounts.clear()  # Clear the list to reset the cumulative amount
    return jsonify(success=True)

@app.route('/membership')
def membership():
    return render_template('includes/membership.html')

#membershipbackend
@app.route('/membershipbackend')
def membership_backend():
    # Retrieve promo codes from the promo_code database
    promo_codes = []
    with shelve.open('promo_codes_db') as db:
        if 'promo_codes' in db:
            promo_codes = db['promo_codes']

    return render_template('backend/membershipbackend.html', promo_codes=promo_codes)


#shipping and delivery
@app.route('/shipdelivery')
def shipping_and_delivery():
    return render_template('includes/shippinganddelivery.html')

# contact us
class ContactForm:
    def __init__(self, first_name, last_name, email, contact, query, description):
        self.first_name = first_name
        self.last_name = last_name
        self.email = email
        self.contact = contact
        self.query = query
        self.description = description


# Contact Us
@app.route('/contactus', methods=['GET', 'POST'])
def contact_us():
    validation_errors = {}  # Initialize the variable here

    if request.method == 'POST':
        # Retrieve form data
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        email = request.form.get('email')
        contact = request.form.get('contact')
        query = request.form.get('query')
        description = request.form.get('description')

        # Open the contactus.db file
        with shelve.open('contactus.db', 'c', writeback=True) as db:
            # Store data using a unique key (e.g., a UUID) as the key
            contact_id = str(uuid.uuid4())[:7]
            contact_data = db.get('contact_key', {})
            contact_data[contact_id] = {
                'first_name': first_name,
                'last_name': last_name,
                'email': email,
                'contact_number': contact,
                'query': query,
                'description': description
            }
            db['contact_key'] = contact_data

        # Redirect to the thank_you_review route after successful form submission
        return redirect(url_for('thank_you_review'))

    return render_template('includes/contactus.html', validation_errors=validation_errors)

#Hui xin
#customer dashboard
@app.route('/customer-dashboard', methods=['GET', 'POST'])
def customer_dashboard():
    db = shelve.open('Shelves/Customer.db', 'c', writeback=True)
    customer_data = db.get('customer_key', {})
    email = session['email']
    customer = customer_data.get(email)  # Get the customer object from the dictionary
    customer_update_profile = CustomerUpdateProfile(request.form)

    new_username = customer_update_profile.username.data
    new_birthdate = customer_update_profile.birthdate.data
    new_mobile_number = customer_update_profile.mobile_number.data
    new_password = customer_update_profile.password.data

    if request.method == 'POST':
        error = None
        error_username = None
        error_birthdate = None
        error_mobile_number = None
        error_password = None

        # validations
        today = date.today()
        if not customer_update_profile.username.data.isalnum():
            error_username = "Username must only contain letters and numbers."
        elif customer_update_profile.birthdate.data >= today or customer_update_profile.birthdate.data < date(1900, 1, 1):
            error_birthdate = 'Birthdate must be in the past.'
        elif customer_update_profile.mobile_number.data.isdigit() == False:
            error_mobile_number = "Please enter a valid mobile number."
        elif len(customer_update_profile.mobile_number.data) != 8:
            error_mobile_number = "Mobile number must be from Singapore."
        elif not customer_update_profile.password.data.isalnum() or customer_update_profile.password.data.isalpha() \
                or customer_update_profile.password.data.isdigit():
            error_password = "Password must contain both letters and numbers only."
        elif not 8 <= len(customer_update_profile.password.data) <= 32:
            error_password = "Password must be between 8 to 32 characters long."
        else:
            error = None
            # Update data in customer object
            customer_data[email].set_username(new_username)
            customer_data[email].set_birthdate(new_birthdate.strftime('%Y-%m-%d'))
            customer_data[email].set_mobile_number(new_mobile_number)
            customer_data[email].set_password(new_password)

            customer_data[email] = Customer.Customer(customer_data[email].get_username(),
                                                     customer_data[email].get_birthdate(),
                                                     customer_data[email].get_mobile_number(),
                                                     customer_data[email].get_email(),
                                                     new_password)
            db['customer_key'] = customer_data  # Update data in shelve
            db.sync()
            db.close()
        return render_template('includes/customer_dashboard.html', form=customer_update_profile, email=session['email'],
                                username=customer.get_username(), birthdate=customer.get_birthdate(),
                                mobile_number=customer.get_mobile_number(), password=customer.get_password(),
                                error=error, error_username=error_username, error_birthdate=error_birthdate,
                                error_mobile_number=error_mobile_number, error_password=error_password,
                                current_url=request.path)
    else:
        return render_template('includes/customer_dashboard.html', form=customer_update_profile, email=session['email'],
                                username=customer.get_username(), birthdate=customer.get_birthdate(),
                                mobile_number=customer.get_mobile_number(), password=customer.get_password(),
                                current_url=request.path)




@app.route('/products', methods=['GET', 'POST'])
def display():
    if request.method == 'POST':
        product_id = request.form['product_id']
        quantity = int(request.form['quantity'])

        # Validate the quantity (you may want to add more validation)
        if quantity <= 0:
            flash('Quantity must be greater than zero.', 'danger')
        else:
            # Add the product to the cart
            add_to_cart(product_id, quantity)
            flash('Product added to cart successfully!', 'success')

        # Redirect to the product list or another appropriate page after adding to cart
        return redirect(url_for('display'))

    products = get_products()
    categories = get_categories()
    return render_template('includes/products.html', products=products, categories=categories)

def get_customer_id():
    # Retrieve customer ID from the session
    return session.get('customer_id')

# Route to handle the cart page
# Function to retrieve coupons from the promo_codes.db database
def get_coupons():
    with shelve.open('promo_codes.db') as db:
        return db.get('coupons', [])  # Assuming coupons are stored under the 'coupons' key in the database

#shopping cart
@app.route('/cart', methods=['GET', 'POST'])
def cart():
    if request.method == 'POST':
        # Handle quantity updates when the form is submitted
        product_id = int(request.form.get('product_id'))
        new_quantity = int(request.form.get('quantity'))
        # Redirect to the cart page to update the view
        return redirect(url_for('cart'))

    # For GET requests, render the cart page
    cart_items = get_cart_items()

    total_price = calculate_total_price(cart_items)

    if total_price >= 300:
        # Apply $10 ($20?) discount for total price over $300
        total_price -= 20
    elif total_price >= 200:
        # Apply $15 discount for total price over $200
        total_price -= 15
    elif total_price >= 100:
        # Apply $20 ($10) discount for total price over $100
        total_price -= 10

    # Retrieve the customer ID from the customer database
    customer_id = get_customer_id()

    return render_template('includes/cart.html', cart_items=cart_items, total_price=total_price,customer_id=customer_id)


# Route to clear the cart
@app.route('/clear_cart', methods=['POST'])
def clear_cart_route():
    clear_cart()
    return redirect(url_for('cart'))

# Route to remove a specific item from the cart
@app.route('/remove_from_cart/<product_id>', methods=['POST'])
def remove_from_cart_route(product_id):
    remove_from_cart(product_id)
    return redirect(url_for('cart'))


# Thank You Review
@app.route('/thank_you_review')
def thank_you_review():
    return render_template('includes/thank_you_review.html')

@app.route('/termsnconditions')
def termsnconditions():
    return render_template('includes/termsnconditions.html')

@app.route('/purchasehistory', methods=['GET'])
def purchase_history():
    # Open the purchase history database
    purchase_history_db = shelve.open('purchase_history.db', 'r')

    # Retrieve all orders from the purchase history database
    purchase_history = []
    for order_id, order_data in purchase_history_db.items():
        purchase_history.append({
            'order_id': order_id,
            'order': order_data['order'],
            'payment_method': order_data['payment_method'],
            'amount': order_data['amount']
        })

    # Close the purchase history database
    purchase_history_db.close()

    return render_template('includes/purchasehistory.html', purchase_history=purchase_history)

# Backend display product
@app.route('/backendproducts')
def backend_display():
    products = get_products()
    return render_template('backend/backend_products.html', products=products)

# allowing to upload product images and stored in the file .
UPLOAD_FOLDER = 'static/images'
ALLOWED_EXTENSIONS = {'jpg', 'jpeg', 'png', 'gif'}
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER


def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS


# PRODUCTS CREATION/ADDING
@app.route('/add_product', methods=['GET', 'POST'])
def add_product():
    if request.method == 'POST':
        name = request.form['name']
        price = float(request.form['price'])
        category = request.form['category']
        description = request.form['description']
        quantity = request.form['quantity']
        sku = request.form['sku']

        # Check if the post request has the file part
        if 'image' not in request.files:
            flash('No file part', 'danger')
            return redirect(request.url)

        # save and display the uploaded image
        image = request.files['image']

        # Check if the file has an allowed extension
        if image and allowed_file(image.filename):
            filename = os.path.join(app.config['UPLOAD_FOLDER'], f"{time.time()}.jpg")
            image.save(filename)

            # Generate a unique ID for the product
            product_id = str(time.time())

            # Call the save_product function with the correct arguments
            save_product(product_id, name, price, category, description, filename, quantity,sku)

            # Flash a success message
            flash('Product has been added successfully!', 'success')

            # Redirect to the add_product page to display the updated list
            return redirect(url_for('add_product'))

        else:
            flash('Invalid file format. Please upload a valid image.', 'danger')

    # If the request method is not POST, render the form with categories
    categories = get_categories()

    # Get the list of products for display
    products = get_products()

    # Render the template with the list of products and categories
    return render_template('backend/add_product.html', categories=categories, products=products)

#products indiviual pages
@app.route('/metallix')
def metallix_page():
    metallix_products = get_metallix_products()
    return render_template('includes/products/metallix_page.html', products=metallix_products)

@app.route('/restyle')
def restyle_page():
    restyle_products = get_restyle_products()
    return render_template('includes/products/restyle_page.html', products=restyle_products)

@app.route('/biopack')
def biopack_page():
    biopack_products = get_biopack_products()
    return render_template('includes/products/biopack_page.html', products=biopack_products)

@app.route('/greentech')
def greentech_page():
    greentech_products = get_greentech_products()
    return render_template('includes/products/greentech_page.html', products=greentech_products)

# DISPLAYING PRODUCT AT HOMEPAGE
@app.route('/product')
def product():
    # Get the list of products for display on the home page
    categories = get_categories()
    products = get_products()

    # Render the template with the list of products
    return render_template('includes/products.html', products=products, categories=categories)


# DISPLAYING BACKEND PRODUCT FOR ADMIN
@app.route('/backproduct')
def backproduct():
    products = get_products()
    categories=get_categories()
    # Render the template with the list of products
    return render_template('backend/backend_products.html', products=products, categories=categories)


@app.route('/delete_product/<product_id>', methods=['GET', 'POST'])
def delete_product_route(product_id):
    delete_product(product_id)
    if success:
        flash('Product has been deleted successfully!', 'Success')
    else:
        flash('Failed to delete product.', 'Error')
    return redirect(url_for('backproduct'))


def generate_unique_id():
    return int(time.time() * 1000)

#main product page
@app.route('/')
def existing_page():
    categories = get_categories()
    return render_template('includes/products.html', categories=categories)


# Add category
@app.route('/add_category', methods=['GET', 'POST'])
def add_category():
    if request.method == 'POST':
        category_name = request.form['category_name']

        # Save the category to the database
        save_category(category_name)

        # Flash a success message
        flash('Category added successfully!', 'success')

        # Redirect to the add_category page to display the updated list and show the flash message
        return redirect(url_for('add_category'))

    # Get the list of categories for display
    categories = get_categories()

    # Retrieve flashed messages
    messages = get_flashed_messages(with_categories=True)

    # Render the template with the list of categories and flashed messages
    return render_template('backend/add_category.html', categories=categories, messages=messages)


# Delete category
@app.route('/delete_category/<category_id>', methods=['POST'])
def delete_category_route(category_id):
    delete_category(category_id)
    # Flash a success message
    flash('Category deleted successfully!', 'success')

    # Fetch updated categories after deletion
    categories = get_categories()
    return redirect(url_for('add_category',categories=categories))


@app.route('/edit_product/<product_id>', methods=['GET', 'POST'])
def edit_product(product_id):
    # Retrieve the product details from your data store (e.g., database, Shelve, etc.)
    product = get_product_by_id(product_id)

    # Retrieve the list of categories
    categories = get_categories()

    if request.method == 'POST':
        # Handle the form submission to update the product details
        updated_name = request.form['name']
        updated_price = float(request.form['price'])
        updated_category = request.form['category']
        updated_description = request.form['description']
        updated_quantity = int(request.form['quantity'])
        updated_sku = request.form['sku']

        # Update the product details in your data store
        update_product(product_id, updated_name, updated_price, updated_category, updated_description, updated_quantity
                       ,updated_sku)

        if success:
            flash('Product has been updated successfully!', 'Success')
        else:
            flash('Failed to update product. Product not found.', 'Error')

        # Redirect to the product list or another appropriate page after the update
        return redirect(url_for('edit_product', product_id=product_id))

    # Render the edit product form with the current details
    return render_template('backend/edit_product.html', product=product, categories=categories)


def get_products_without_image_paths():
    products = get_products()  # Assuming you have a get_products function
    # Remove the 'image_path' key from each product dictionary
    products_without_images = [{k: v for k, v in product.items() if k != 'image_path'} for product in products]
    return products_without_images

@app.route('/db_products')
def db_products():
    products = get_database_pd()
    return render_template('backend/db_products.html' , products=products)



@app.route('/database')
def database():
    top_5_products = get_top_5_products()
    # Retrieve the list of categories
    categories = get_categories()
    return render_template('backend/database.html',top_5_products=top_5_products,categories=categories)


@app.route('/delete_database_pd/<product_id>', methods=['GET', 'POST'])
def delete_pd_route(product_id):
    delete_product(product_id)
    if success:
        flash('Product has been deleted successfully!', 'Success')
    else:
        flash('Failed to delete product.', 'Error')
    return redirect(url_for('db_products'))

#Retrieve and read database categories
@app.route('/database_categories')
def show_categories():
    categories = get_categories()
    return render_template('backend/db_category.html', categories=categories)


@app.route('/edit_dbcategory/<category_id>', methods=['GET', 'POST'])
def edit_dbcategory(category_id):
    # Retrieve the category details from your data store
    category = get_category_by_id(category_id)

    if request.method == 'POST':
        # Handle the form submission to update the category details
        updated_name = request.form['name']

        # Validate form data and update the category
        if not updated_name:
            flash('Category name cannot be empty.', 'error')
        else:
            update_dbcategory(category_id, updated_name)
            flash('Category has been updated successfully!', 'success')

            # Redirect to the categories list or another appropriate page after the update
            return redirect(url_for('show_categories'))

    return render_template('backend/edit_db_category.html', category=category)



# Export into excel sheet for product list section
@app.route('/export_excel', methods=['GET'])
def export_excel():
    # Retrieve current products without image paths from the Shelve database
    products = get_products_without_image_paths()

    # If no products found, you may want to handle this case (flash message or redirect)

    # Convert the product data to a pandas DataFrame
    df = pd.DataFrame(products)

    # Create a BytesIO object to store the Excel file
    excel_output = BytesIO()

    # Create a Pandas Excel writer using XlsxWriter as the engine
    with pd.ExcelWriter(excel_output, engine='xlsxwriter') as writer:
        # Convert the DataFrame to an XlsxWriter Excel object
        df.to_excel(writer, index=False, sheet_name='Products')

    # Set the cursor position to the beginning of the BytesIO object
    excel_output.seek(0)

    # Send the Excel file as a response to the user
    return send_file(
        excel_output,
        mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        as_attachment=True,
        download_name='products.xlsx'
    )

#Hui xin chatbot code
# List to store chat messages

chat_messages = []

@app.route('/send_message', methods=['POST'])
def send_message():
    user_input = request.form.get('user_input')

    if user_input:
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        formatted_message = f'[{timestamp}] User: {user_input}'

        chat_messages.append(formatted_message)

        return jsonify({'status': 'success'})
    else:
        return jsonify({'status': 'error', 'message': 'Empty message'})


@app.route('/get_messages')
def get_messages():
    return jsonify({'messages': chat_messages})

def chatbot_response(user_message):
    user_message_lower = user_message.lower()

    if any(greeting in user_message_lower for greeting in ['hi', 'hello', 'hey']):
        return "Greetings! How can I help you?"

    elif 'how are you' in user_message_lower:
        return "I'm just a chatbot, but thanks for asking!"

    elif any(greeting in user_message_lower for greeting in ['bye', 'goodbye']):
        return "Bye! Have a good day!"

    elif 'language' in user_message_lower:
        return "I currently understand only English. Please use Google Translate if needed."

    elif 'paper bag' in user_message_lower:
        reference_link = 'https://www.example.com/products/paper-bag'
        return f"Sure! You can find details about the paper bag [here]({reference_link}). <br> Are there any other inquiries?"

    elif 'polymailer' in user_message_lower:
        reference_link = 'https://www.example.com/products/polymailer'
        return f"Sure! You can find details about the polymailer [here]({reference_link}). <br> Are there any other inquiries?"

    elif 'plastic bag' in user_message_lower:
        reference_link = 'https://www.example.com/products/plastic-bag'
        return f"Sure! You can find details about the plastic bag [here]({reference_link}). <br> Are there any other inquiries?"

    else:
        if not is_english(user_message_lower):
            return "Sorry, I only understand English. Please use Google Translate and send the response. Thank you."

        return "I'm not sure how to respond to that. Can you please be more specific?"

def is_english(text):
    try:
        text.encode(encoding='utf-8').decode('ascii')
    except UnicodeDecodeError:
        return False
    else:
        return True


@app.route('/chatbot_records')
def chatbot_records():
    # Retrieve chat messages from the database
    messages = retrieve_chat_messages()

    # Pre-process messages to include an 'is_user' flag
    processed_messages = []
    is_user = True  # Assume the first message is from the user

    for message in messages:
        processed_messages.append({'content': message, 'is_user': is_user})
        is_user = not is_user  # Toggle between user and chatbot


    # Render the chatbot_records.html template and pass the messages to it
    return render_template('backend/chatbot_records.html', messages=processed_messages)



@app.route('/chat', methods=['POST'])
def chat():
    user_message = request.form['user_message']

    # Generate chatbot response
    response = chatbot_response(user_message)

    # Append user and chatbot messages to chat_messages list
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    user_formatted_message = f'[{timestamp}] User: {user_message}'
    chat_messages.append(user_formatted_message)

    chatbot_formatted_message = f'[{timestamp}] Chatbot: {response}'
    chat_messages.append(chatbot_formatted_message)

    # Store messages using shelves
    store_chat_messages(chat_messages)

    return response


@app.route('/delete_message', methods=['POST'])
def delete_message():
    index_to_delete = int(request.form.get('index'))

    if 0 <= index_to_delete < len(chat_messages):
        deleted_message = chat_messages.pop(index_to_delete)

        # Store the updated chat messages in shelve
        store_chat_messages(chat_messages)

        return jsonify({'success': True, 'deleted_message': deleted_message})
    else:
        return jsonify({'success': False, 'message': 'Invalid index'}), 400

#End of Hui xin chatbot code^#

# View stored contact data
@app.route('/view_contact_data')
def view_contact_data():
    try:
        # Open the shelve file
        with shelve.open('contactus.db', 'r') as db:
            # Access the stored data
            contact_data = db.get('contact_key', {})
            contacts = []
            for contact_id, contact_info in contact_data.items():
                contacts.append({
                    'contact_id': contact_id,
                    'first_name': contact_info['first_name'],
                    'last_name': contact_info['last_name'],
                    'email': contact_info['email'],
                    'contact_number': contact_info.get('contact_number', ''),  # Use .get() to handle missing key
                    'query': contact_info['query'],
                    'description': contact_info['description'],
                })

        return render_template('backend/contactresponses.html', contacts=contacts)

    except Exception as e:
        return f"Error: {str(e)}"


# Route for database ability to delete
@app.route('/delete_contact/<int:contact_id>', methods=['POST'])
def delete_contact(contact_id):
    with shelve.open('contactus.db', 'w') as db:
        contact_data = db.get('contact_key', {})
        if contact_id in contact_data:
            del contact_data[contact_id]
            db['contact_key'] = contact_data

    return redirect(url_for('view_contact_data'))


#CHATBOT BACKEND
@app.route('/chatbotbackend')
def chatbotbackend():
    return render_template('backend/chatbot_records.html')

@app.route('/Suppliers')
def suppliers():
    return render_template('includes/Suppliers.html', current_url=request.path)

@app.route('/submit_supplier_form', methods=['POST'])
def submit_supplier_form():
    if request.method == 'POST':
        # Retrieve form data
        supplier_name = request.form['supplierName']
        contact_person = request.form['contactPerson']
        email = request.form['email']
        phone = request.form['phone']
        product = request.form['product']
        quantity = request.form['quantity']

        # Retrieve or initialize the supplier counter
        with shelve.open('counters') as counters_db:
            supplier_counter = counters_db.get('supplier_counter', 0)
            supplier_id = str(supplier_counter + 1)
            counters_db['supplier_counter'] = supplier_counter + 1

        # Store form data in the shelve database
        with shelve.open('supplier_data') as db:
            db[supplier_id] = {
                'supplier_name': supplier_name,
                'contact_person': contact_person,
                'email': email,
                'phone': phone,
                'product': product,
                'quantity': quantity
            }

        # Redirect to thank-you page with the supplier_id
        return redirect(url_for('thank_you', supplier_id=supplier_id))

#Megan Code
@app.route('/thank_you/<supplier_id>', methods=['GET', 'POST'])
def thank_you(supplier_id):
    if request.method == 'POST':
        # Handle delete button click
        with shelve.open('supplier_data') as db:
            # Check if the supplier_id exists before deleting
            if supplier_id in db:
                del db[supplier_id]
        return redirect(url_for('view_suppliers'))

    return render_template('includes/thank_supplier.html', supplier_id=supplier_id)

@app.route('/view_suppliers')
def view_suppliers():
    # Retrieve all supplier data from the shelve database
    with shelve.open('supplier_data') as db:
        suppliers_data = list(db.values())

    return render_template('backend/view_suppliers.html', suppliers_data=suppliers_data)


#megan Code
# Submit Thank you Review
@app.route('/submit_review', methods=['POST'])
def submit_review():
    if request.method == 'POST':
        # Handle the review submission logic
        rating = request.form['rating']
        review_text = request.form['review_text']

        with shelve.open('reviews.db') as db:
            reviews = db.get('reviews', [])
            reviews.append({'rating': int(rating), 'review_text': review_text})
            db['reviews'] = reviews

        # After submitting the review, redirect to the homepage
        return redirect(url_for('index'))

    return "Method Not Allowed", 405


@app.route('/view_reviews')
def view_reviews():
    with shelve.open('reviews.db') as db:
        reviews = db.get('reviews', [])

    return render_template('backend/db_view_reviews.html', reviews=reviews)
#End of megan code

#Hui xin
#newsletter thank you page
@app.route('/newsletterthankyou')
def newsletter_thank_you():
    return render_template('includes/newsletterthankyou.html')

#newsletter backend
@app.route('/newsletterbackend', methods=['GET'])
def newsletter_backend():
    # Retrieve subscribed emails using the function
    subscribed_emails = retrieve_subscribed_emails()
    return render_template('backend/newsletterbackend.html', retrieve_subscribed_emails=retrieve_subscribed_emails, subscribed_emails=subscribed_emails)

@app.route('/subscribe_to_newsletter', methods=['POST'])
def subscribe_to_newsletter():
    email = request.form.get('email')

    # Store the email in the Shelve database
    store_subscribed_email(email)

    print(f"Subscribed email: {email}")

    return redirect(url_for('newsletter_thank_you'))


@app.route('/delete_subscribed_email', methods=['POST'])
def delete_subscribed_email():
    email_to_delete = request.form.get('email')
    subscribed_emails = retrieve_subscribed_emails()

    if email_to_delete in subscribed_emails:
        subscribed_emails.remove(email_to_delete)

        # Store the updated subscribed emails in shelve
        if store_subscribed_email(subscribed_emails):
            return redirect(url_for('newsletter_backend'))
        else:
            return jsonify({'success': False, 'message': 'Failed to update subscribed emails'}), 500
    else:
        return jsonify({'success': False, 'message': 'Email not found'}), 404


#End of hui xin code


#Nithia Code statistics
@app.route('/statistics')
def generate_statistics():
    # Get the latest products and categories
    products = get_products()
    categories = get_categories()

    # Extract category names
    category_names = [category['name'] for category in categories]

    # Count the occurrences of each category in the products
    category_counts = Counter(product['category'] for product in products)

    # Extract counts for each category
    counts = [category_counts.get(category, 0) for category in category_names]

    # Get the products data
    with shelve.open('products.db') as products_db:
        products = list(products_db.values())

    # Extract product names and quantities from the products
    product_names = [product['name'] for product in products]
    quantities = [product['quantity'] for product in products]

    # Create a dictionary to store total quantities by product name
    product_totals = {}
    for product_name, quantity in zip(product_names, quantities):
        if product_name in product_totals:
            product_totals[product_name] += quantity
        else:
            product_totals[product_name] = quantity

    # Extract product names and corresponding total quantities
    product_names = list(product_totals.keys())
    total_quantities = list(product_totals.values())

    # Open the purchase history database
    purchase_history_db = shelve.open('purchase_history.db', 'r')

    # Retrieve all orders from the purchase history database
    orders = [(order_id, data) for order_id, data in purchase_history_db.items()]

    # Close the purchase history database
    purchase_history_db.close()

    # Extract total sales
    total_sales = [order[1]['amount'] for order in orders]

    # Render the template with the data and total sales
    return render_template('backend/statistics(sales).html',
                           category_names=category_names,
                           counts=counts,
                           product_names=product_names,
                           total_quantities=total_quantities,
                           total_sales=total_sales)



#Orders backend
@app.route('/orders')
def orders():
    # Open the purchase history database
    purchase_history_db = shelve.open('purchase_history.db', 'r')

    # Retrieve all orders from the purchase history database
    orders = [(order_id, data) for order_id, data in purchase_history_db.items()]

    # Close the purchase history database
    purchase_history_db.close()

    return render_template('backend/orders.html', orders=orders)

@app.route('/delete_order/<order_id>', methods=['POST'])
def delete_order(order_id):
    # Open the purchase history database
    purchase_history_db = shelve.open('purchase_history.db', 'w')

    # Check if the order exists
    if order_id in purchase_history_db:
        # Delete the order
        del purchase_history_db[order_id]
        purchase_history_db.close()
        return redirect(url_for('orders'))
    else:
        purchase_history_db.close()
        return "Order not found", 404

#nithia code
@app.errorhandler(404)
def page_not_found(e):
    return render_template('includes/404error.html'), 404



@app.route('/search', methods=['GET'])
def search():
    # Get the search query from the request parameters
    search_query = request.args.get('search_query', '')

    # Perform the search based on the search query
    search_results = perform_search(search_query)

    # Check if the search query matches 'about us' and set the page to highlight
    page_to_highlight = 'About Us' if search_query.lower() == 'about us' else None

    # Render the search results template with the search results and page to highlight
    return render_template('search_results.html', search_results=search_results, search_query=search_query, page_to_highlight=page_to_highlight)



if __name__ == '__main__':
    app.run(debug=True)


    #👽  OFFICALLY APPDEV PET
    # List to store chat messages
    chat_messages = retrieve_chat_messages()

